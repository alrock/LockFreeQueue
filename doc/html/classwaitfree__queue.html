<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LockFreeQueue: Шаблон класса waitfree_queue&lt; T &gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Создано системой Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Титульная&nbsp;страница</span></a></li>
      <li class="current"><a href="annotated.html"><span>Классы</span></a></li>
      <li><a href="files.html"><span>Файлы</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Поиск" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Классы</span></a></li>
      <li><a href="classes.html"><span>Алфавитный&nbsp;указатель&nbsp;классов</span></a></li>
      <li><a href="hierarchy.html"><span>Иерархия&nbsp;классов</span></a></li>
      <li><a href="functions.html"><span>Члены&nbsp;классов</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Открытые члены</a> &#124;
<a href="#pro-types">Защищенные типы</a> &#124;
<a href="#pro-methods">Защищенные члены</a>  </div>
  <div class="headertitle">
<h1>Шаблон класса waitfree_queue&lt; T &gt;</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="waitfree_queue" -->
<p>Producer/Consumer wait-free queue Очередь предназначенная для работы между двумя потоками, один из которых добавляет в неё элементы, другой читает. Как добавление, так и чтение может производиться только в одном потоке. Шаблонный параметр T в силу лени разработчиков должен быть типом, который не являеся ни указателем, ни ссылкой. В очереди все данные хранятся по указателю, но всё-же возможно добавлять данные через перегруженный метод produce, который принимает константную ссылку и снимает копию данных для хранения в очереди.  
<a href="#_details">Подробнее...</a></p>

<p><code>#include &lt;<a class="el" href="lockfreequeue_8h_source.html">lockfreequeue.h</a>&gt;</code></p>

<p><a href="classwaitfree__queue-members.html">Полный список членов класса</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Открытые члены</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b2984f85fbe81a356c0d012db454924"></a><!-- doxytag: member="waitfree_queue::waitfree_queue" ref="a8b2984f85fbe81a356c0d012db454924" args="(const queue_type &amp;q)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>waitfree_queue</b> (const <a class="el" href="classwaitfree__queue.html">queue_type</a> &amp;q)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97a3c5230237dc12966aa7d2aea9604b"></a><!-- doxytag: member="waitfree_queue::operator=" ref="a97a3c5230237dc12966aa7d2aea9604b" args="(const queue_type &amp;q)" -->
<a class="el" href="classwaitfree__queue.html">waitfree_queue</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classwaitfree__queue.html">queue_type</a> &amp;q)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9649f7336a0663475809ab2281fe238"></a><!-- doxytag: member="waitfree_queue::is_empty" ref="ae9649f7336a0663475809ab2281fe238" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwaitfree__queue.html#ae9649f7336a0663475809ab2281fe238">is_empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Проверка на пустоту Безопасна для вызова только из потока, производящего извлечение. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a590ccdfee4cfdfdea6dde2a7efe4dc51"></a><!-- doxytag: member="waitfree_queue::size" ref="a590ccdfee4cfdfdea6dde2a7efe4dc51" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwaitfree__queue.html#a590ccdfee4cfdfdea6dde2a7efe4dc51">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Не реализовано. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a6526245f078103f56786d3deaf4963"></a><!-- doxytag: member="waitfree_queue::produce" ref="a2a6526245f078103f56786d3deaf4963" args="(pointer v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwaitfree__queue.html#a2a6526245f078103f56786d3deaf4963">produce</a> (pointer v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Добавляет данные в конец очереди Этот метод должен вызываться только в одном потоке. В этом случае он безопасен относительно операции извлечения. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a829c0ea48bffa3f8ac1c19c1854c33a6"></a><!-- doxytag: member="waitfree_queue::consume" ref="a829c0ea48bffa3f8ac1c19c1854c33a6" args="()" -->
pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwaitfree__queue.html#a829c0ea48bffa3f8ac1c19c1854c33a6">consume</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Извлекает данные из очереди Этот метод должен вызываться только в одном потоке. В этом случае он безопасен относительно операции добавления. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Защищенные типы</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af644cf4c46892f0121fa4a99862f6461"></a><!-- doxytag: member="waitfree_queue::node_base" ref="af644cf4c46892f0121fa4a99862f6461" args="" -->
typedef <a class="el" href="struct_list_node_base__.html">ListNodeBase_</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>node_base</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af164bdcea91d2fec2290c5aedc9e9df6"></a><!-- doxytag: member="waitfree_queue::queue_type" ref="af164bdcea91d2fec2290c5aedc9e9df6" args="" -->
typedef <a class="el" href="classwaitfree__queue.html">waitfree_queue</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>queue_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf7664d74820ba59aba8505ff29e9908"></a><!-- doxytag: member="waitfree_queue::reference" ref="abf7664d74820ba59aba8505ff29e9908" args="" -->
typedef T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3d57ed0d8c6fd8ad7e519e2eefe7fad"></a><!-- doxytag: member="waitfree_queue::const_reference" ref="aa3d57ed0d8c6fd8ad7e519e2eefe7fad" args="" -->
typedef const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8ce86bb111bf9535928bb0a25c51876"></a><!-- doxytag: member="waitfree_queue::pointer" ref="ac8ce86bb111bf9535928bb0a25c51876" args="" -->
typedef T *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae19b160f1c45e692a98af1223c3c9834"></a><!-- doxytag: member="waitfree_queue::node" ref="ae19b160f1c45e692a98af1223c3c9834" args="" -->
typedef <a class="el" href="struct_list_node__.html">ListNode_</a>&lt; pointer &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6649fc682acd2015998e3bdbe5710481"></a><!-- doxytag: member="waitfree_queue::size_type" ref="a6649fc682acd2015998e3bdbe5710481" args="" -->
typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Защищенные члены</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67e6125b470ec797de795c4fb241abcc"></a><!-- doxytag: member="waitfree_queue::make_empty_node" ref="a67e6125b470ec797de795c4fb241abcc" args="()" -->
<a class="el" href="struct_list_node__.html">node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>make_empty_node</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a148aad4d432cc4a757894e83d40dda9b"></a><!-- doxytag: member="waitfree_queue::fill_node" ref="a148aad4d432cc4a757894e83d40dda9b" args="(node *n, pointer v)" -->
<a class="el" href="struct_list_node__.html">node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>fill_node</b> (<a class="el" href="struct_list_node__.html">node</a> *n, pointer v)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Подробное описание</h2>
<h3>template&lt;typename T&gt;<br/>
 class waitfree_queue&lt; T &gt;</h3>

<p>Producer/Consumer wait-free queue Очередь предназначенная для работы между двумя потоками, один из которых добавляет в неё элементы, другой читает. Как добавление, так и чтение может производиться только в одном потоке. Шаблонный параметр T в силу лени разработчиков должен быть типом, который не являеся ни указателем, ни ссылкой. В очереди все данные хранятся по указателю, но всё-же возможно добавлять данные через перегруженный метод produce, который принимает константную ссылку и снимает копию данных для хранения в очереди. </p>
<hr/>Объявления и описания членов класса находятся в файле:<ul>
<li>queue/<a class="el" href="lockfreequeue_8h_source.html">lockfreequeue.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>Указатель</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Классы</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Функции</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Перечисления</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Документация по LockFreeQueue. Последние изменения: Sat Feb 12 2011 19:15:40. Создано системой&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
